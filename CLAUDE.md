# SEPilot Desktop (v0.9.2)

Electron + Next.js 기반 LLM Desktop Application

- 다중 대화 세션 관리, 이미지 생성/해석, RAG, MCP Tool calling, LangGraph Agent 지원
- Frontend: Next.js 16 (React 19, TypeScript 5.9, shadcn/ui, Tailwind CSS 4)
- Backend: Electron 39 Main Process (Node.js, TypeScript)
- 상태 관리: Zustand 5 (Slice 패턴, Persistence)
- AI/ML: LangChain + LangGraph 1.0.7, MCP (Model Context Protocol)
- 통신: IPC (Inter-Process Communication)

## 작업 전 필수 확인

1. 파일 수정 전 반드시 Read 도구로 먼저 읽기
2. 새 파일보다 기존 파일 수정 우선
3. 작업 완료 후 `pnpm run lint` 및 `pnpm run type-check` 실행
4. 항상 git pull 을 하여 merge conflict를 방지 할 것

## 수정 금지 규칙 (CRITICAL)

아래 파일/패턴은 Extension 로딩 시스템의 핵심이므로 **절대 함부로 수정하지 말 것**. 수정 시 전체 Extension이 로드 실패할 수 있음.

### 절대 수정 금지 파일

| 파일/패턴                                           | 이유                                                           |
| --------------------------------------------------- | -------------------------------------------------------------- |
| `scripts/wrap-extension-renderer.js`                | IIFE wrapper 생성 스크립트. dist/renderer.js의 유일한 생성자   |
| `lib/extensions/loader.ts`                          | Extension 런타임 로딩 핵심. sepilot-ext:// 프로토콜 로딩 로직  |
| `lib/extensions/loader-runtime.ts`                  | Extension 런타임 로더. **SEPILOT_MODULES** 등록 로직           |
| `lib/extensions/loader-main.ts`                     | Main Process Extension 로더                                    |
| `electron/main.ts`의 CSP 설정                       | `sepilot-ext:` 프로토콜 허용 설정. 제거 시 Extension 로드 실패 |
| `electron/main.ts`의 `sepilot-ext://` 프로토콜 등록 | Extension 파일 서빙의 핵심                                     |

### Extension tsup.config.ts 수정 규칙

- **`src/renderer.tsx`를 tsup entry에 절대 추가하지 말 것**
  - `dist/renderer.js`는 `wrap-extension-renderer.js`가 `dist/index.js`를 IIFE로 감싸서 생성
  - tsup이 `src/renderer.tsx`를 직접 빌드하면 IIFE wrapper를 덮어써서 "module is not defined" 오류 발생
  - 올바른 빌드 체인: `tsup → dist/index.js (CJS)` → `wrap-extension-renderer.js → dist/renderer.js (IIFE)`
- **`format: ['cjs']`를 변경하지 말 것** — ESM으로 변경 시 IIFE wrapper 호환 불가
- **`external` 목록에서 `@sepilot/extension-sdk` 제거하지 말 것** — SDK는 호스트에서 제공

### Extension 로딩 관련 수정 시 필수 확인

1. 수정 전: 현재 Extension이 정상 로드되는지 확인
2. 수정 후: `pnpm run build:extensions` 후 `dist/renderer.js` 첫 줄이 IIFE wrapper인지 확인
3. IIFE wrapper 확인 방법: `head -n 5 resources/extensions/*/dist/renderer.js` → `Auto-generated by wrap-extension-renderer.js` 포함되어야 함

## 작업 후 해야 할일

1. release_notes/ 폴더에 있는 현재 버전의 문서를 업데이트 할 것 (한국어로)

---

## 핵심 아키텍처

### 전체 구조 개요

```
┌─────────────────────────────────────────────────────┐
│  Renderer Process (Frontend)                        │
│  ┌───────────┐ ┌──────────┐ ┌────────────────────┐  │
│  │ Next.js   │ │ React    │ │ Extension UI       │  │
│  │ App Router│ │ Components│ │ (동적 로드)         │  │
│  └─────┬─────┘ └────┬─────┘ └────────┬───────────┘  │
│        │             │                │              │
│        └─────────────┼────────────────┘              │
│                      │                               │
│              window.electronAPI                      │
│                      │ (IPC invoke / on)             │
├──────────────────────┼───────────────────────────────┤
│  Main Process (Backend)                              │
│                      │                               │
│  ┌───────────────────┼────────────────────────────┐  │
│  │           IPC Handler Registry                 │  │
│  │  ┌──────┐ ┌─────┐ ┌─────┐ ┌────┐ ┌─────────┐ │  │
│  │  │ LLM  │ │Graph│ │ MCP │ │File│ │Extension│ │  │
│  │  │Handle│ │Handle│ │Handle│ │Handle│ │Handle │ │  │
│  │  └──┬───┘ └──┬──┘ └──┬──┘ └──┬─┘ └────┬────┘ │  │
│  └─────┼────────┼───────┼───────┼─────────┼──────┘  │
│        │        │       │       │         │          │
│  ┌─────▼──┐ ┌──▼────┐ ┌▼────┐ ┌▼──────┐ ┌▼───────┐ │
│  │LLM     │ │Lang   │ │MCP  │ │DB     │ │Extension│ │
│  │Provider│ │Graph  │ │Server│ │Service│ │Runtime │ │
│  └────────┘ └───────┘ └─────┘ └───────┘ └────────┘ │
└─────────────────────────────────────────────────────┘
```

### IPC 통신 패턴

- **Frontend → Backend**: `window.electronAPI.invoke('channel-name', data)` 또는 카테고리별 API (`window.electronAPI.llm.streamChat()`)
- **Backend → Frontend (스트리밍)**: `event.sender.send('channel-name', data)` — 실시간 토큰 스트리밍
- **스트리밍 격리**: `conversationId` 기반으로 다중 동시 스트림 지원, AbortController로 취소 가능
- IPC 핸들러는 `electron/ipc/handlers/`에 배치 (32개 핸들러 파일)

### 스트리밍 흐름 (LLM)

```
React Component → window.electronAPI.llm.streamChat(messages)
                        ↓ IPC invoke
          electron/ipc/handlers/llm.ts
                        ↓
          LLMProvider.stream() (AsyncGenerator)
                        ↓ for await
          event.sender.send('llm-stream-chunk', chunk)  ← 실시간
                        ↓
          event.sender.send('llm-stream-done')
```

### 스트리밍 흐름 (LangGraph Agent)

```
React Component → window.electronAPI.langgraph.stream(config, messages, conversationId)
                        ↓ IPC invoke
          electron/ipc/handlers/langgraph.ts
                        ↓
          GraphFactory.streamWithConfig() → Graph.stream()
                        ↓ for await (streamEvent)
          type: 'streaming' → event.sender.send('langgraph-stream-event', {chunk})
          type: 'node'      → 이전 content와 diff 계산 후 전송
          type: 'tool_approval_request' → Human-in-the-loop 승인 요청
                        ↓
          event.sender.send('langgraph-stream-done')
```

### 데이터 저장

- 임시/캐시: localStorage 사용 가능
- 영구 저장: Electron fs API로 파일 시스템에 저장 (`app.getPath('userData')`)
- DB: SQLite (sql.js, better-sqlite3) — 대화, 활동, 설정 저장

---

## 디렉토리 구조

```
sepilot_desktop/
├── app/                          # Next.js App Router (Frontend)
│   ├── layout.tsx                # Root 레이아웃
│   ├── page.tsx                  # 메인 페이지
│   ├── globals.css               # 글로벌 스타일
│   ├── api/chat/stream/          # 스트리밍 채팅 API
│   ├── notification/             # 알림 페이지
│   └── quick-input/              # 빠른 입력 페이지
│
├── components/                   # React 컴포넌트
│   ├── ui/                       # shadcn/ui 기본 컴포넌트 (Button, Dialog, Input 등)
│   ├── chat/                     # 채팅 UI (Phase 1: Unified 구조로 통합)
│   │   ├── unified/              # Unified Chat 시스템
│   │   │   ├── UnifiedChatArea.tsx      # 통합 채팅 영역 (18KB)
│   │   │   ├── UnifiedChatInput.tsx     # 통합 입력 (46KB)
│   │   │   ├── hooks/            # 8개 훅 (useChatMessages, useMessageStreaming 등)
│   │   │   └── plugins/          # 9개 플러그인 (Persona, ToolApproval 등)
│   │   ├── ChatContainer.tsx     # 채팅 컨테이너
│   │   ├── CodeDiffViewer.tsx    # 코드 비교 뷰어
│   │   └── WorkingDirectoryIndicator.tsx  # 작업 디렉토리 표시
│   ├── layout/                   # 레이아웃 (MainLayout, Sidebar, ChatHistory, WikiTree)
│   ├── settings/                 # 설정 (LLM, MCP, Extension, Network 등 20+ 탭)
│   ├── rag/                      # RAG 문서 관리 UI
│   ├── markdown/                 # Markdown 렌더링
│   ├── mcp/                      # MCP 관련 UI
│   ├── skills/                   # 스킬 관련 UI
│   ├── persona/                  # 페르소나 관련 UI
│   ├── gallery/                  # 이미지 갤러리
│   ├── providers/                # React Context Provider
│   ├── theme/                    # 테마 컴포넌트
│   └── ErrorBoundary.tsx         # 에러 바운더리
│
├── electron/                     # Electron Main Process
│   ├── main.ts                   # 앱 진입점 (윈도우, 서비스 초기화, 프로토콜 등록)
│   ├── preload.ts                # Preload 스크립트 (electronAPI 노출)
│   ├── ipc/
│   │   ├── index.ts              # IPC 핸들러 등록 총괄
│   │   ├── handlers/             # IPC 핸들러 (Phase 2: feature별 그룹화)
│   │   │   ├── llm/              # LLM 관련 IPC 핸들러
│   │   │   ├── chat/             # Chat 관련 IPC 핸들러
│   │   │   ├── mcp/              # MCP 관련 IPC 핸들러
│   │   │   ├── extension/        # Extension 관련 IPC 핸들러
│   │   │   ├── file/             # File 관련 IPC 핸들러
│   │   │   ├── browser/          # Browser 관련 IPC 핸들러
│   │   │   ├── terminal/         # Terminal 관련 IPC 핸들러
│   │   │   ├── agent/            # Agent 관련 IPC 핸들러 (LangGraph)
│   │   │   ├── data/             # Data 관련 IPC 핸들러 (VectorDB, Embeddings)
│   │   │   ├── integration/      # 외부 통합 (GitHub, ComfyUI, Team Docs)
│   │   │   ├── system/           # 시스템 관련 (Config, Auth, Update, Notification)
│   │   │   ├── skill/            # Skill 관련 IPC 핸들러
│   │   │   └── quick-input/      # Quick Input 관련 IPC 핸들러
│   │   └── utils/                # IPC 유틸리티
│   ├── services/                 # 백엔드 서비스 (14개)
│   │   ├── database.ts           # SQLite 데이터베이스 (32KB)
│   │   ├── vectordb.ts           # 벡터 DB 서비스
│   │   ├── pty-manager.ts        # PTY 터미널 관리
│   │   ├── message-queue.ts      # 메시지 큐
│   │   ├── scheduler.ts          # 작업 스케줄러
│   │   └── ...
│   ├── agents/                   # Electron 에이전트
│   └── utils/                    # 유틸리티 (paths, update-checker)
│
├── lib/                          # 공유 라이브러리
│   ├── domains/                  # 도메인별 비즈니스 로직 (Phase 3: 도메인 구조화)
│   │   ├── chat/                 # 채팅 도메인 (~10KB)
│   │   ├── llm/                  # LLM 도메인 (~100KB)
│   │   │   ├── base.ts           # BaseLLMProvider (추상 클래스)
│   │   │   ├── client.ts         # LLMClient 싱글톤
│   │   │   ├── service.ts        # LLM 서비스
│   │   │   ├── providers/        # LLM 제공자
│   │   │   │   ├── openai.ts     # OpenAI 호환 (Anthropic, Gemini, Ollama 포함)
│   │   │   │   └── ollama.ts     # Ollama 전용
│   │   │   ├── streaming-callback.ts # 스트리밍 콜백 (대화별 격리)
│   │   │   └── vision-utils.ts   # 비전 모델 유틸리티
│   │   ├── agent/                # Agent 도메인 (LangGraph, ~620KB)
│   │   │   ├── base/             # 기본 그래프 클래스 (base-graph, thinking-graph)
│   │   │   ├── graphs/           # 그래프 구현 (15개)
│   │   │   │   ├── chat-graph.ts         # 기본 채팅
│   │   │   │   ├── agent-graph.ts        # Tool calling 에이전트
│   │   │   │   ├── coding-agent-graph.ts # 코딩 에이전트 (가장 복잡, 73KB)
│   │   │   │   ├── rag-graph.ts          # RAG (문서 검색 + 생성)
│   │   │   │   ├── deep-thinking-graph.ts     # 깊은 사고
│   │   │   │   ├── sequential-thinking-graph.ts # 순차 사고
│   │   │   │   ├── tree-of-thought-graph.ts   # 트리 구조 사고
│   │   │   │   └── deep-web-research-graph.ts # 웹 리서치
│   │   │   ├── nodes/            # 그래프 노드 (generate, retrieve, tools)
│   │   │   ├── factory/          # GraphFactory + GraphRegistry (그래프 선택/생성)
│   │   │   ├── prompts/          # 시스템 프롬프트
│   │   │   ├── utils/            # LangGraph 유틸리티 (13개)
│   │   │   ├── state.ts          # 그래프 상태 정의
│   │   │   └── skills-injector.ts # 스킬 주입기
│   │   ├── mcp/                  # MCP 도메인 (~230KB)
│   │   │   ├── client.ts         # MCP 클라이언트 (JSON-RPC 2.0)
│   │   │   ├── server-manager.ts # MCP 서버 생명주기 관리
│   │   │   ├── tools/            # MCP 도구 (9개: Google Search, Browser 등)
│   │   │   └── transport/        # 전송 (SSE, Stdio)
│   │   ├── rag/                  # RAG 도메인 (VectorDB, ~80KB)
│   │   │   ├── client.ts         # VectorDB 클라이언트
│   │   │   ├── indexing.ts       # 문서 인덱싱
│   │   │   ├── adapters/         # DB 어댑터
│   │   │   └── embeddings/       # 임베딩 생성
│   │   ├── auth/                 # 인증 도메인 (~30KB)
│   │   │   ├── github-oauth.ts   # GitHub OAuth
│   │   │   └── session.ts        # 세션 관리
│   │   ├── config/               # 설정 도메인 (~40KB)
│   │   │   ├── manager.ts        # 설정 관리
│   │   │   ├── encryption.ts     # 암호화
│   │   │   └── migration.ts      # 설정 마이그레이션
│   │   ├── document/             # 문서 처리 도메인 (~50KB)
│   │   │   ├── parsers/          # 문서 파서 (PDF, Word, Excel)
│   │   │   └── indexer.ts        # 문서 인덱서
│   │   ├── integration/          # 외부 통합 도메인 (~120KB)
│   │   │   ├── github/           # GitHub 통합
│   │   │   ├── comfyui/          # ComfyUI 통합
│   │   │   └── imagegen/         # 이미지 생성
│   │   └── skill/                # 스킬 도메인 (~20KB)
│   │       ├── manager.ts        # 스킬 관리
│   │       ├── validator.ts      # 스킬 검증
│   │       └── loader.ts         # 스킬 로더
│   │
│   ├── extensions/               # Extension 시스템 (유지)
│   │   ├── loader.ts             # Renderer 환경 로더
│   │   ├── loader-main.ts        # Main Process 로더
│   │   ├── loader-runtime.ts     # 런타임 로더
│   │   ├── registry.ts           # Extension 레지스트리
│   │   ├── context-factory.ts    # Extension 런타임 컨텍스트 생성
│   │   ├── agent-builder.ts      # Agent 빌더
│   │   ├── browser-context-bridge.ts  # Browser Extension 브릿지
│   │   └── editor-context-bridge.ts   # Editor Extension 브릿지
│   │
│   ├── extension-sdk/            # Extension SDK (유지)
│   │   └── src/
│   │       ├── types/            # SDK 타입 (ExtensionManifest, ExtensionDefinition 등)
│   │       ├── hooks/            # SDK React 훅
│   │       ├── ipc/              # IPC 통신 헬퍼
│   │       ├── runtime/          # 런타임 API
│   │       └── ui/               # UI 컴포넌트
│   │
│   ├── store/                    # Zustand 전역 상태 (유지)
│   │   ├── chat-store.ts         # 핵심 상태 (79KB) — 대화, 메시지, 그래프 설정, Extension 상태
│   │   ├── extension-slices.ts   # Extension Store 슬라이스 (동적 병합)
│   │   ├── scheduler-slice.ts    # 스케줄러 상태
│   │   └── editor-defaults.ts    # 에디터 기본값
│   │
│   ├── utils/                    # 공통 유틸리티 (유지)
│   │   ├── logger.ts             # 로거
│   │   ├── token-counter.ts      # 토큰 카운터
│   │   └── error-handler.ts      # 에러 핸들러
│   ├── hooks/                    # React 훅 (유지)
│   ├── http/                     # HTTP 클라이언트 (유지)
│   └── i18n/                     # 국제화 (유지)
│
├── resources/extensions/         # Extension 런타임 (8개 Extension)
│   ├── editor/                   # 코드 에디터 Extension
│   ├── browser/                  # 웹 브라우저 Extension
│   ├── terminal/                 # 터미널 Extension
│   ├── architect/                # 아키텍처 Extension
│   ├── presentation/             # 프레젠테이션 Extension
│   ├── github-actions/           # GitHub Actions Extension
│   ├── github-pr-review/         # GitHub PR Review Extension
│   └── github-project/           # GitHub Project Extension
│
├── extensions/                   # .sepx 패키지 파일 (프로덕션 배포용)
├── types/                        # TypeScript 타입 정의
├── locales/                      # 다국어 리소스
├── public/                       # 정적 자산
├── docs/                         # 프로젝트 문서
├── release_notes/                # 릴리스 노트
└── .claude/                      # Claude Code 설정
    ├── settings.json             # 팀 공유 설정
    ├── commands/                 # 커스텀 슬래시 명령어
    ├── agents/                   # Subagent 정의
    └── skills/                   # 프로젝트 전문 지식
```

---

## Extension 시스템 아키텍처

### Extension 개요

모든 Extension은 External (.sepx) 방식으로 로드됩니다. Built-in Extension 개념은 제거되었습니다.

### Extension 구조

각 Extension은 다음 구조를 따릅니다:

```
resources/extensions/{id}/
├── src/
│   ├── definition.ts         # ExtensionDefinition export
│   ├── manifest.ts           # Manifest 정의
│   ├── main.ts               # Main Process 진입점 (IPC 핸들러)
│   ├── renderer.tsx          # Renderer 진입점 (UI)
│   ├── components/           # Extension UI 컴포넌트
│   ├── agents/               # LangGraph Agent 구현
│   ├── tools/                # Tool Registry
│   ├── hooks/                # React 훅
│   ├── locales/              # 다국어 리소스 (ko.json, en.json)
│   └── types/                # 타입 정의
├── dist/                     # 빌드 출력 (tsup)
├── manifest.json             # Extension 메타데이터
├── package.json              # 의존성
└── tsup.config.ts            # 빌드 설정
```

### Extension Manifest

```typescript
interface ExtensionManifest {
  id: string; // 고유 ID (소문자, 숫자, 하이픈)
  name: string; // Extension 표시 이름
  description: string; // Extension 설명
  version: string; // Semantic version
  author: string; // 작성자
  icon: string; // 아이콘 (lucide-react 아이콘 이름)
  mode: string; // App mode (editor, browser 등)
  showInSidebar: boolean; // 사이드바 표시 여부
  dependencies?: string[]; // 의존 Extension ID 목록
  settingsSchema?: Record<string, unknown>; // 설정 스키마
  enabled?: boolean; // 활성화 여부
  order?: number; // 표시 순서
  betaFlag?: string; // 베타 기능 플래그
  ipcChannels?: {
    handlers: string[]; // Extension IPC handler 목록
  };
  processType?: 'renderer' | 'main' | 'both'; // 프로세스 타입
  settingsTab?: {
    id: string;
    label: string;
    description: string;
    icon: string;
  };
  agents?: AgentManifest[]; // LangGraph Agent 선언
  permissions?: string[]; // ["filesystem:read", "llm:chat" 등]
  exports?: Record<string, any>; // Export 항목
}
```

### Extension Definition

```typescript
interface ExtensionDefinition {
  manifest: ExtensionManifest;
  MainComponent?: ComponentType; // 메인 UI
  SidebarComponent?: ComponentType; // 사이드바 UI
  SettingsComponent?: ComponentType; // 설정 UI
  createStoreSlice?: StoreSliceCreator; // Zustand store slice
  setupIpcHandlers?: () => void; // Main Process IPC 핸들러
  activate?: (context: ExtensionContext) => void | Promise<void>;
  deactivate?: (context: ExtensionContext) => void | Promise<void>;
}
```

### Extension 로딩 흐름

```
앱 시작
  ↓
[Main Process]
  registerExtensionHandlers()           ← IPC 핸들러 먼저 등록 (빈 Registry에서도 안전)
  loadAllExtensions()
    → exeDir/extensions/*.sepx          ← 일반 빌드
    → PORTABLE_EXECUTABLE_DIR/extensions/*.sepx  ← Portable 빌드
    → userData/extensions/*.sepx        ← 사용자 설치
  → extensionRegistry.register(extension)
  → extension.activate(context)
  → webContents.send('extensions:main-ready')
  ↓
[Renderer Process]
  waitForMainExtensionsReady()          ← 이벤트 + IPC 폴링 + 타임아웃 3중 대기
  → IPC: extension:list-renderer-extensions
  → loadExtensionRuntime() × N         ← sepilot-ext:// 프로토콜로 로드
  → extensionRegistry.register()
  → groupByDependencyLevel() → activate()
  → registerExtensionSlice() (Zustand store 동적 병합)
  ↓
[Extension 활성화]
  → MainComponent, SidebarComponent, SettingsComponent 렌더링
  → IPC 통신 시작
```

### Extension Runtime Context

각 Extension은 격리된 런타임 컨텍스트를 받습니다:

```typescript
interface ExtensionRuntimeContext {
  ipc: IPCBridge; // IPC invoke/on/send
  logger: Logger; // Extension별 로거
  platform: PlatformInfo; // isElectron, isMac, isWindows, isLinux
  workspace: WorkspaceAPI; // 파일 시스템 접근
  ui: UIAPI; // Toast, Dialog
  commands: CommandAPI; // 명령어 등록
  tools: ToolRegistry; // 네임스페이스 격리된 Tool 레지스트리
  agent: AgentBuilder; // LangGraph Agent 빌더
  llm: LLMProvider; // 격리된 LLM 클라이언트
  vectorDB: VectorDBAccess; // 권한 기반 벡터 DB 접근
}
```

### .sepx 파일 형식

.sepx는 ZIP 아카이브이며, 다음을 포함합니다:

```
extension.sepx (ZIP)
├── manifest.json     (필수)
├── dist/             (컴파일된 JS)
├── assets/           (아이콘 등)
├── locales/          (다국어)
└── README.md         (선택)
```

보안 검증: Path Traversal 방지, Extension ID 형식 검증 (`^[a-z0-9-]+$`)

### Extension 경로 주의사항 (Portable 빌드)

Portable 빌드(`pnpm build:portable`)에서 Extension 경로 관련 코드를 수정할 때 반드시 알아야 할 사항:

- **Portable EXE는 `%TEMP%`에 앱을 추출 후 실행** — `app.getPath('exe')`, `process.resourcesPath`, `app.getAppPath()` 모두 임시 폴더를 가리킴
- **원본 EXE 위치는 `process.env.PORTABLE_EXECUTABLE_DIR`로만 접근 가능**
- Extension .sepx 파일 탐색 경로를 수정할 때 반드시 `PORTABLE_EXECUTABLE_DIR`을 포함할 것
- Extension IPC 핸들러(`registerExtensionHandlers()`)는 Extension 로딩 전에 등록해야 함 (Registry 실시간 읽기하므로 빈 상태에서도 안전)
- `extensions:main-ready` 이벤트는 Renderer가 놓칠 수 있으므로 IPC 폴링 대비 필요

```
Portable 빌드 경로 매핑:
  process.env.PORTABLE_EXECUTABLE_DIR  → 원본 EXE 디렉토리 ✅
  app.getPath('exe')                   → %TEMP% 임시 폴더   ❌
  process.resourcesPath                → %TEMP% 임시 폴더   ❌
  app.getAppPath()                     → %TEMP% 내 app.asar ❌
```

> 상세 내용: `docs/extensions/03-runtime-loading.md` 섹션 6.4 참조

### Extension 런타임 로딩 (v0.9.2 개선)

**프로덕션 빌드에서 Extension 정상 로드를 위한 필수 설정:**

#### 1. CSP 설정 (electron/main.ts)

`sepilot-ext:` 프로토콜을 CSP에 추가:

```typescript
// connect-src에 반드시 포함
"connect-src 'self' http: https: ws: wss: data: blob: sepilot-ext:";
```

#### 2. Manifest 엔트리 경로 (manifest.json)

IIFE wrapper 포함 번들 사용:

```json
{
  "renderer": "dist/renderer.js" // ✅ 올바름 (이전: dist/index.js ❌)
}
```

#### 3. Extension 빌드 형식 (tsup.config.ts)

CJS 형식으로 통일:

```typescript
export default defineConfig({
  format: ['cjs'], // ✅ 올바름 (이전: 조건부 ESM/CJS ❌)
  // ...
});
```

#### ⚠️ tsup entry에 renderer.tsx 포함 금지 (v0.9.2 수정)

```typescript
// ❌ 절대 금지 — IIFE wrapper를 덮어씀
entry: ['src/main.ts', 'src/index.tsx', 'src/renderer.tsx'],

// ✅ 올바름 — renderer.js는 wrap-extension-renderer.js가 생성
entry: ['src/main.ts', 'src/index.tsx'],
```

**이유:** tsup이 `src/renderer.tsx`를 빌드하면 `dist/renderer.js`를 plain CJS로 출력하여, `wrap-extension-renderer.js`가 만든 IIFE wrapper를 덮어씁니다. 브라우저에서 `module is not defined` 오류가 발생하여 Extension 전체가 로드 실패합니다.

#### 4. Extension 로딩 체인

```
tsup → dist/index.js (CJS)
  ↓ wrap-extension-renderer.js
dist/renderer.js (IIFE wrapper)
  ↓ sepilot-ext:// protocol
Browser Runtime (custom require())
  ↓
globalThis.__SEPILOT_EXTENSIONS__[id]
```

**IIFE wrapper 역할:**

- 브라우저 환경에서 `module`, `exports`, `require` 제공
- `globalThis.__SEPILOT_MODULES__`에서 의존성 조회
- Extension 자동 등록

### Extension 모듈 Import 주의사항

Extension 런타임에서는 `<script>` 태그로 CJS 번들을 로드하며, IIFE 래퍼의 custom `require()`가 `globalThis.__SEPILOT_MODULES__`에서 의존성을 해석합니다. 다음 규칙을 반드시 따를 것:

- **`next/dynamic(() => import('...'))`을 사용하지 말 것** — 네이티브 `import()`는 브라우저에서 bare specifier를 해석할 수 없어 `Failed to resolve module specifier` 오류 발생
- **Extension에서 bare specifier를 사용하는 `import()` 호출을 금지** — `import('react')`, `import('@monaco-editor/react')` 등 모두 실패
- **항상 정적 `import`/`require()`를 사용** — tsup CJS 출력에서 `require()`로 변환되어 래퍼가 처리
- Electron Renderer에서는 SSR이 없으므로 `next/dynamic`의 `ssr: false` 옵션 자체가 불필요
- 외부 모듈은 `tsup.config.ts`의 `external` 목록에 추가하고, `host-module-registry.ts`에 등록되어 있는지 확인

### Extension Agent 그래프 Import (v0.9.2 개선)

Extension agent 그래프는 Electron Main Process 전용이므로 Next.js 빌드에서 제외:

```typescript
// lib/domains/agent/factory/graph-factory.ts
const module = await import(
  /* webpackIgnore: true */ // ← webpack 번들링 건너뛰기
  `@sepilot/extension-${extensionId}/agents/${graphType}`
);
```

**next.config.js 설정:**

```javascript
// webpack alias에 $ suffix 추가 (prefix match 방지)
'@sepilot/extension-editor$': path.resolve(__dirname, 'resources/extensions/editor/dist/index.js'),
'@sepilot/extension-editor/agents': path.resolve(__dirname, 'resources/extensions/editor/dist/agents')
```

**tsup 진입점:**

```typescript
// resources/extensions/editor/tsup.config.ts
entry: {
  index: 'src/definition.ts',
  renderer: 'src/renderer.tsx',
  main: 'src/main.ts',
  'agents/editor-agent-graph': 'src/agents/editor-agent-graph.ts',  // ← 반드시 포함
}
```

### Extension 상태 관리 주의사항 (중요)

Extension에서 Zustand store를 사용할 때 **React 리렌더링**을 보장하기 위해 다음 패턴을 반드시 따를 것:

#### ❌ 잘못된 패턴: Context getter만 사용

```typescript
// 문제: React가 상태 변경을 감지하지 못함
const context = useExtensionAPIContext();
const messages = context.chat.messages; // getter만 호출, 구독 없음
```

**문제점:**

- `context.chat.messages`는 getter로만 구현되어 Zustand 구독이 없음
- Store가 업데이트되어도 React 컴포넌트가 **리렌더링되지 않음**
- UI에 변경사항이 반영되지 않음

#### ✅ 올바른 패턴: Zustand hook 직접 사용

```typescript
// 해결: Zustand의 구독 메커니즘 활용
import { useExtensionStore, getExtensionStoreState } from '@sepilot/extension-sdk/store';

function MyComponent() {
  // 1. useExtensionStore()로 상태 구독 - 자동 리렌더링
  const { browserChatMessages, addBrowserChatMessage, updateBrowserChatMessage } =
    useExtensionStore();

  // 2. 이벤트 핸들러에서 최신 상태 가져오기 (클로저 문제 해결)
  const handleStream = useCallback(() => {
    const eventHandler = (event) => {
      // getExtensionStoreState()로 항상 최신 상태 참조
      const currentMessages = getExtensionStoreState().browserChatMessages || [];
      const lastMessage = currentMessages[currentMessages.length - 1];

      if (lastMessage) {
        updateBrowserChatMessage(lastMessage.id, { content: event.chunk });
      }
    };
  }, [updateBrowserChatMessage]);
}
```

**핵심 원칙:**

1. **컴포넌트 레벨**: `useExtensionStore()` **selector 없이** 사용 → 자동 리렌더링
2. **이벤트 핸들러**: `getExtensionStoreState()` 사용 → 최신 상태 참조
3. **Context API는 보조적으로만 사용** → IPC 호출이나 비상태 API에만 사용

#### ⚠️ SDK 내부 구현: React native useSyncExternalStore

Extension IIFE 런타임에서 Zustand의 `useSyncExternalStoreWithSelector`가 React 리렌더링을 트리거하지 않는 문제가 있어, `lib/extension-sdk/src/store/index.ts`에서 **React의 native `useSyncExternalStore`를 직접 사용**합니다. Zustand 훅을 호출하지 않습니다.

```typescript
// SDK 내부 구현 (lib/extension-sdk/src/store/index.ts)
import { useSyncExternalStore } from 'react';

export function useExtensionStore<T>(selector?: (state: any) => T): T | any {
  const store = getStore(); // globalThis.__SEPILOT_SDK_STORE__ (= useChatStore)
  const state = useSyncExternalStore(store.subscribe, store.getState, store.getState);
  return selector ? selector(state) : state;
}
```

**이 변경은 Host App의 webpack 번들에 적용됩니다** (Extension 빌드와 무관). Extension은 `require('@sepilot/extension-sdk/store')`로 이 모듈을 Host의 module registry에서 가져옵니다.

#### Extension 컴포넌트에서 사용 패턴

```typescript
// ✅ selector 없이 전체 store destructure (권장)
const {
  editorChatMessages = [],
  editorChatStreaming = false,
  addEditorChatMessage,
  updateEditorChatMessage,
} = useExtensionStore();

// ✅ selector 사용도 가능 (SDK가 useSyncExternalStore로 처리)
const messages = useExtensionStore((s: any) => s.editorChatMessages);
```

**증상 (수정 전):** Store 데이터는 업데이트되지만 UI에 반영되지 않음. 다른 Extension으로 전환 후 돌아와야 최신 상태가 표시됨.

### Extension 로딩 타이밍 주의사항 (중요)

#### useExtension() vs useExtensions() 사용 구분

Host App의 Sidebar나 Layout 컴포넌트에서 현재 Extension을 참조할 때 반드시 올바른 hook을 사용할 것.

#### ❌ 잘못된 패턴: useExtension(mode) 사용

```typescript
// 문제: mode가 변경될 때만 재실행 — Extension 로드 이벤트에 반응하지 않음
const currentExtension = useExtension(appMode);
```

**문제점:**

- `useExtension(mode)`는 `[mode]` 의존성으로만 `useEffect`가 실행됨
- Sidebar 첫 렌더링 시 `appMode='editor'`인데 Extension이 아직 로드되지 않아 `null` 반환
- Extension 로드 완료 후에도 mode가 변경되지 않으면 `useEffect`가 재실행되지 않음
- 결과: `currentExtension = null` 고정 → `HeaderActionsComponent`, `SidebarComponent` 마운트 안 됨
- **증상:** Extension의 버튼이 화면에 표시되지 않고 클릭해도 반응 없음 (콘솔 로그조차 없음)

#### ✅ 올바른 패턴: useExtensions() 사용

```typescript
// 해결: extensionsVersion을 구독하여 Extension 로드 시 자동 업데이트
const { activeExtensions: allExtensions } = useExtensions();
const currentExtension = allExtensions.find((ext) => ext.manifest.mode === appMode) ?? null;
```

**이유:**

- `useExtensions()`는 `extensionsVersion` Zustand store를 구독함
- Extension이 로드될 때 `extensionsVersion`이 증가 → 컴포넌트 자동 리렌더링
- `activeExtensions`가 최신 상태를 반영하여 `currentExtension`이 올바르게 설정됨

#### Extension 개발 시 createStoreSlice 필수 구현

새 Extension을 개발하거나 기존 Extension에 상태가 필요할 때 반드시 `createStoreSlice`를 구현할 것.

```typescript
// resources/extensions/{id}/src/store/index.ts
export function create{Id}Slice(set, get, context) {
  return {
    // 상태 초기값
    myState: 'initial',

    // 액션
    setMyState: (value) => { set({ myState: value }); },
  };
}

// resources/extensions/{id}/src/index.tsx
import { create{Id}Slice } from './store';

const myExtension: ExtensionDefinition = {
  manifest,
  MainComponent: MainComponentWithContext,
  createStoreSlice: create{Id}Slice,  // ← 반드시 포함
  // ...
};
```

**누락 시 증상:** `setMyState` 등 Extension 전용 액션이 `undefined`로 반환될 수 있음 (chat-store에 이미 동명 함수가 있으면 작동하는 것처럼 보일 수 있어 발견이 어려움).

### Extension 개발 워크플로우

**개발 모드** (`pnpm run dev`):

- `resources/extensions/` 디렉토리에서 직접 로드
- `tsup --watch`로 자동 빌드
- Hot Reload 지원 (브라우저 새로고침만 필요)

**프로덕션 빌드** (`pnpm run bundle:extensions`):

- .sepx 파일 생성 및 `resources/extensions/`로 추출

```bash
# 개발 서버 (Extension watch 포함)
pnpm run dev

# .sepx 파일 수동 빌드
pnpm run bundle:extensions
```

---

## LangGraph 에이전트 시스템

### 사용 가능한 그래프 (15개)

| 그래프                    | 설명                                           |
| ------------------------- | ---------------------------------------------- |
| chat-graph                | 기본 채팅                                      |
| agent-graph               | Tool calling 에이전트                          |
| coding-agent-graph        | 코딩 전문 에이전트 (가장 복잡)                 |
| rag-graph                 | RAG (문서 검색 + 생성)                         |
| deep-thinking-graph       | 깊은 사고/추론                                 |
| sequential-thinking-graph | 순차적 사고                                    |
| tree-of-thought-graph     | 트리 구조 사고                                 |
| deep-web-research-graph   | 웹 리서치                                      |
| + Extension 그래프        | browser-agent, editor-agent, terminal-agent 등 |

### GraphFactory 패턴

```typescript
// 그래프 등록
GraphFactory.initialize()
  → registry.register('chat', ChatGraph)
  → registry.register('coding-agent', CodingAgentGraph)
  → registry.register('browser-agent', BrowserAgentGraph)  // Extension에서 동적 import

// 그래프 실행
GraphFactory.streamWithConfig(graphConfig, messages, options)
  → registry.get(graphConfig.graphType)
  → graph.stream(initialState, options)
```

### Human-in-the-Loop (도구 승인)

LangGraph Agent가 도구를 실행하기 전 사용자 승인을 요청할 수 있습니다:

```
Agent → toolApprovalCallback(toolCalls)
  → event.sender.send('tool_approval_request', toolCalls)
  → UI에서 승인/거부 다이얼로그 표시
  → window.electronAPI.langgraph.respondToolApproval(conversationId, approved)
  → Agent 실행 재개 또는 중단
```

---

## 주요 IPC 채널 요약

| 카테고리  | 주요 채널                                                           | 스트리밍 |
| --------- | ------------------------------------------------------------------- | -------- |
| LLM       | llm-stream-chat, llm-chat, llm-init, llm-validate                   | O        |
| LangGraph | langgraph-stream, langgraph-abort, langgraph-tool-approval-response | O        |
| MCP       | mcp-add-server, mcp-call-tool, mcp-get-all-tools                    | X        |
| Chat      | chat-save, chat-load, chat-delete                                   | X        |
| File      | file:read, fs:read-file, fs:write-file, fs:search-files             | X        |
| VectorDB  | vectordb-search, vectordb-insert, vectordb-index-documents          | X        |
| Extension | extension:discover, extension:install, extension:install-from-file  | X        |
| Terminal  | terminal:execute-command, terminal:create-session                   | X        |
| Browser   | browser-view:load-url, browser-view:execute-script                  | X        |

---

## CLI Agent 시스템

### 개요

SEPilot Desktop은 `--agent` 옵션 없이도 CLI 명령어를 지원합니다. `sepilot agent` 명령어로 GUI 없는 Headless Agent를 실행할 수 있습니다.

### CLI 모드 감지

```
electron/main.ts → isCLIMode(process.argv)
  → true: runCLI() 실행 후 process.exit()
  → false: GUI 윈도우 생성
```

### Agent 명령어 아키텍처

```
sepilot agent -p "prompt" --mode coding
  → electron/cli/index.ts (Commander.js 파싱)
  → electron/cli/commands/agent.ts
    → initializeAgentRuntime()
      → databaseService.initialize()
      → initializeLLMClient(config)
      → GraphFactory.initialize()
    → runSinglePrompt() 또는 runInteractiveTUI()
      → GraphFactory.streamWithConfig()
```

### CLI 개발 시 주의사항

- `app.whenReady()` 호출 필수 (app.getPath() 사용을 위해)
- CLI 모드에서는 headless 플래그 설정 (GPU 비활성화)
- `databaseService` → `LLMClient` → `GraphFactory` 순서로 초기화
- 새 CLI 명령어 추가 시 `electron/cli/commands/`에 파일 생성 후 `index.ts`에 등록

---

## 컴포넌트 설계 원칙

- 작고 재사용 가능한 컴포넌트 구성
- shadcn/ui 컴포넌트 활용 (`components/ui/`)
- 비즈니스 로직과 UI 분리
- Radix UI + Tailwind CSS 기반 스타일링
- i18next 기반 다국어 지원

## 상태 관리 (Zustand)

**chat-store.ts** (핵심 전역 상태):

- 대화 목록, 메시지, 앱 모드, 그래프 설정
- 페르소나, 작업 디렉토리, 열린 파일
- Extension Store Slices (동적 병합)
- 스케줄러, UI 설정
- localStorage + Electron DB 동기화

---

## 보안 및 커밋

### 필수 검증

- API 키, 토큰, 비밀번호 하드코딩 금지
- 사용자 경로, 개인정보 포함 시 커밋 전 경고
- XSS, SQL Injection, Command Injection 방지
- MCP 도구 인자 sanitization (prototype pollution 차단)
- Extension Path Traversal 방지
- **Portable 빌드 경로**: `app.getPath('exe')` 대신 `process.env.PORTABLE_EXECUTABLE_DIR` 사용 (Extension 경로 관련 코드 수정 시)
- **Extension IPC 핸들러 등록 순서**: `registerExtensionHandlers()`는 Extension 로딩 전에 호출 (레이스 컨디션 방지)
- **Main→Renderer 이벤트**: `extensions:main-ready` 같은 이벤트는 Renderer가 놓칠 수 있으므로 IPC 폴링 병행 필요

### 커밋 규칙

- **한국어** 커밋 메시지 작성
- Semantic Commit 형식: `feat:`, `fix:`, `chore:`, `docs:`, `refactor:`
- 관련 파일끼리 그룹화하여 분할 커밋

---

## 개발 명령어

```bash
# 개발
pnpm run dev                  # 전체 개발 (Next.js + Electron + Extensions)
pnpm run dev:next             # Next.js만
pnpm run dev:electron         # Electron만
pnpm run dev:extensions       # Extension watch

# 빌드
pnpm run build                # 전체 빌드
pnpm run build:extensions     # Extension만
pnpm run bundle:extensions    # .sepx 파일 생성
pnpm run build:mac/win/linux  # OS별 빌드

# 품질 관리
pnpm run lint                 # ESLint
pnpm run type-check           # TypeScript 타입 검사
pnpm run format               # Prettier

# 테스트
pnpm run test                 # 전체 테스트
pnpm run test:frontend        # 프론트엔드
pnpm run test:backend         # 백엔드
pnpm run test:e2e             # E2E (Playwright)

# 분석
pnpm run depcruise            # 의존성 분석
pnpm run depcruise:graph      # 의존성 그래프 SVG
```

---

## Claude Code 활용

### Skills (자동 활용되는 전문 지식)

Claude Code가 자동으로 참조하는 프로젝트별 전문 지식:

**기본 개발 패턴:**

- **electron-ipc**: Electron IPC 통신 패턴 및 보안 가이드
- **typescript-strict**: TypeScript strict mode 타입 작성 규칙
- **react-shadcn**: React + shadcn/ui 컴포넌트 개발 패턴

**품질 및 최적화:**

- **testing-patterns**: Jest, React Testing Library, Playwright 테스트 패턴
- **error-handling**: 에러 처리, 로깅, Error Boundary, 사용자 피드백
- **performance-optimization**: React 최적화, IPC 최적화, 번들 크기 최적화
- **logging-monitoring**: 로깅, 디버깅, 모니터링 패턴 (개발/프로덕션 환경)

**상태 및 데이터 관리:**

- **state-management**: Zustand 전역 상태 관리, Slice 패턴, Persistence
- **file-operations**: 파일 읽기/쓰기, PDF/Word/Excel 처리, 이미지 처리

**UI 및 디자인:**

- **ui-design-system**: shadcn/ui 디자인 시스템, Tailwind CSS 패턴, cva, 아이콘

**Extension 개발:**

- **extension-development**: Extension 구조, Manifest, Agent 통합, Store slice, Components, IPC 핸들러

**AI/ML 통합:**

- **langgraph-agent**: LangGraph 에이전트 구현 및 그래프 기반 워크플로우
- **mcp-integration**: MCP (Model Context Protocol) 도구 통합 패턴
- **rag-vector-search**: RAG 및 벡터 검색 구현 가이드

**국제화 및 빌드:**

- **i18n-localization**: 다국어 지원 (i18next), 한/영/중, Extension 번역
- **build-deployment**: Electron 빌드 및 배포 (electron-builder, 멀티 플랫폼)

Skills는 자동으로 적용되며, 별도로 호출할 필요 없음.

### Slash Commands (바로가기 명령어)

**코드 품질:**

- `/review [파일경로]` - 코드 리뷰 (품질, 보안, 타입 안전성)
- `/security` - 보안 취약점 검사 (커밋 전 필수)

**개발 작업:**

- `/feature [이름] [설명]` - 새 기능 설계 및 구현
- `/component [이름] [설명]` - React 컴포넌트 생성
- `/debug [이슈설명]` - 버그 디버깅 및 수정

**빌드 및 테스트:**

- `/test [패턴]` - 테스트 실행 및 실패 수정
- `/build` - 애플리케이션 빌드 및 에러 수정
- `/commit` - 변경사항 검토 및 한국어 커밋 생성

### Subagents (전문 에이전트)

- **code-reviewer**: 코드 품질, 보안, 타입 안전성 검토
- **architect**: 시스템 설계, 아키텍처 결정, 기능 설계
- **debugger**: 버그 추적, 원인 분석, 수정 제안

## Hooks 설정

현재 모든 hooks는 비활성화 상태 (`disableAllHooks: true`):

- pre-commit hook이 변경사항을 되돌리지 않도록 설정됨
- Claude Code 작업 시 자유롭게 파일 수정 가능
- 커밋 전 수동으로 lint/type-check 실행 권장
