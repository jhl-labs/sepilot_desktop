{
  "systemPrompt": "당신은 SEPilot Desktop 프로젝트에서 작업하고 있습니다. CLAUDE.md에 정의된 아키텍처 원칙을 기반으로 다음 코드 작성 패턴을 따릅니다.",
  "knowledge": [
    {
      "title": "IPC 핸들러 코드 패턴",
      "content": "# IPC 핸들러 코드 패턴\n\n> 아키텍처 개요는 CLAUDE.md 참조. 여기서는 코드 예시에 집중합니다.\n\n## IPC 핸들러 작성\n\n```typescript\nimport { ipcMain } from 'electron';\nimport type { IPCResponse } from '../../types/electron';\n\n// ✅ 제네릭 타입 명시\nipcMain.handle(\n  'skills:get-installed',\n  async (): Promise<IPCResponse<InstalledSkill[]>> => {\n    try {\n      const skills = await skillRegistry.getInstalledSkills();\n      return { success: true, data: skills };\n    } catch (error) {\n      console.error('[IPC] error:', error);\n      return { success: false, error: String(error) };\n    }\n  }\n);\n\n// ❌ 제네릭 타입 누락 — IPCResponse<void>로 추론됨\nipcMain.handle('skills:get-installed', async (): Promise<IPCResponse> => {});\n```\n\n## 에러 처리 패턴\n- 항상 try-catch로 에러 처리\n- 에러 메시지를 `String(error)`로 변환\n- 콘솔 로그에 `[IPC]` prefix 사용"
    },
    {
      "title": "TypeScript Strict Mode 코드 예시",
      "content": "# TypeScript Strict Mode 코드 예시\n\n## 인터페이스 정의\n\n```typescript\n// ✅ 모든 사용되는 필드 명시\nexport interface SkillSource {\n  type: SkillSourceType;\n  url?: string;\n  repo?: string;\n  branch?: string;\n  commit?: string;\n  downloadedAt?: number;\n}\n\n// ❌ 타입에 없는 필드 사용 시 에러\nconst source: SkillSource = {\n  type: 'marketplace',\n  url: 'https://...',\n  downloadedAt: Date.now(),  // ← 타입 정의에 없으면 에러\n};\n```\n\n## 중첩 객체 접근\n\n```typescript\n// ✅ 타입 구조에 맞게 접근\ninterface LoadedSkill {\n  skillId: string;\n  package: SkillPackage;  // manifest, content는 여기 안에\n  loadedAt: number;\n}\n\nconst manifest = loadedSkill.package.manifest;  // ✅\nconst manifest = loadedSkill.manifest;           // ❌ 직접 접근 불가\n```"
    },
    {
      "title": "React 컴포넌트 데이터 페칭 패턴",
      "content": "# React 컴포넌트 데이터 페칭 패턴\n\n## Electron API 사용 (올바른 방법)\n\n```typescript\n'use client';\n\nimport { useState, useEffect } from 'react';\n\nexport function MyComponent() {\n  const [data, setData] = useState<MyType[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n\n  useEffect(() => {\n    loadData();\n  }, []);\n\n  const loadData = async () => {\n    setIsLoading(true);\n    try {\n      if (window.electronAPI?.myAPI) {\n        const result = await window.electronAPI.myAPI.getData();\n        if (result.success && result.data) {\n          setData(result.data);\n        }\n      }\n    } catch (error) {\n      console.error('Failed to load data:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return <div>{/* UI */}</div>;\n}\n```\n\n## ❌ HTTP fetch 사용 금지 (Electron 환경)\n\n```typescript\n// ❌ Electron에서는 IPC 사용 — HTTP fetch 불가\nconst response = await fetch('/api/data');\n```"
    },
    {
      "title": "데이터 저장 패턴",
      "content": "# 데이터 저장 패턴\n\n## 저장소 선택 기준\n\n| 데이터 유형 | 저장소 | 예시 |\n|---|---|---|\n| 임시/캐시 | localStorage | UI 상태, 캐시 |\n| 영구 저장 | Electron fs API | 사용자 설정, 대화 기록 |\n| 구조화 데이터 | SQLite | Skills, Conversations |\n\n## SQLite 서비스 패턴\n\n```typescript\nexport class SkillDatabaseService {\n  private db: Database | null = null;\n  \n  initialize(dbPath: string): void {\n    this.db = new Database(dbPath);\n    this.createTables();\n  }\n  \n  getAllSkills(): InstalledSkill[] {\n    const rows = this.db!.prepare('SELECT * FROM skills').all();\n    return rows.map(this.rowToSkill);\n  }\n}\n```\n\n## SQL Injection 방지\n\n```typescript\n// ✅ Prepared statement 사용\nconst stmt = db.prepare('SELECT * FROM skills WHERE id = ?');\nconst skill = stmt.get(skillId);\n\n// ❌ SQL Injection 위험\nconst skill = db.prepare(`SELECT * FROM skills WHERE id = '${skillId}'`).get();\n```"
    }
  ],
  "templates": [
    {
      "id": "ipc-handler",
      "name": "IPC 핸들러 템플릿",
      "description": "새로운 IPC 핸들러를 작성할 때 사용하는 템플릿",
      "prompt": "```typescript\nimport { ipcMain } from 'electron';\nimport type { IPCResponse } from '../../types/electron';\nimport type { {{DataType}} } from '../../types';\n\n/**\n * {{Description}}\n */\nipcMain.handle(\n  '{{channel}}',\n  async (_, {{params}}): Promise<IPCResponse<{{DataType}}>> => {\n    try {\n      // 비즈니스 로직\n      const result = await {{service}}.{{method}}({{params}});\n      return { success: true, data: result };\n    } catch (error) {\n      console.error('[IPC] {{channel}} error:', error);\n      return { success: false, error: String(error) };\n    }\n  }\n);\n```",
      "variables": [
        {
          "name": "channel",
          "description": "IPC 채널 이름 (예: 'skills:get-installed')",
          "required": true
        },
        {
          "name": "DataType",
          "description": "반환 데이터 타입",
          "required": true
        },
        {
          "name": "params",
          "description": "파라미터 목록",
          "required": false,
          "default": ""
        },
        {
          "name": "service",
          "description": "사용할 서비스",
          "required": true
        },
        {
          "name": "method",
          "description": "호출할 메서드",
          "required": true
        },
        {
          "name": "Description",
          "description": "핸들러 설명",
          "required": true
        }
      ]
    },
    {
      "id": "react-component",
      "name": "React 컴포넌트 템플릿",
      "description": "새로운 React 컴포넌트를 작성할 때 사용하는 템플릿",
      "prompt": "```typescript\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport { Button } from '@/components/ui/button';\nimport type { {{DataType}} } from '@/types';\n\ninterface {{ComponentName}}Props {\n  {{props}}\n}\n\nexport function {{ComponentName}}({ {{propsList}} }: {{ComponentName}}Props) {\n  const [data, setData] = useState<{{DataType}}[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n\n  useEffect(() => {\n    loadData();\n  }, []);\n\n  const loadData = async () => {\n    setIsLoading(true);\n    try {\n      if (window.electronAPI?.{{api}}) {\n        const result = await window.electronAPI.{{api}}.{{method}}();\n        if (result.success && result.data) {\n          setData(result.data);\n        }\n      }\n    } catch (error) {\n      console.error('Failed to load data:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div>\n      {/* UI */}\n    </div>\n  );\n}\n```",
      "variables": [
        {
          "name": "ComponentName",
          "description": "컴포넌트 이름 (PascalCase)",
          "required": true
        },
        {
          "name": "DataType",
          "description": "데이터 타입",
          "required": true
        },
        {
          "name": "props",
          "description": "Props 정의",
          "required": false,
          "default": ""
        },
        {
          "name": "propsList",
          "description": "Props 파라미터 목록",
          "required": false,
          "default": ""
        },
        {
          "name": "api",
          "description": "Electron API 이름",
          "required": true
        },
        {
          "name": "method",
          "description": "API 메서드",
          "required": true
        }
      ]
    }
  ]
}
