#!/usr/bin/env node

/**
 * Extension Renderer Bundle Wrapper
 *
 * Extension CJS ë²ˆë“¤(dist/index.js)ì„ ë˜í•‘í•˜ì—¬ dist/renderer.jsë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 * Custom require() êµ¬í˜„ìœ¼ë¡œ globalThis.__SEPILOT_MODULES__ì—ì„œ ì˜ì¡´ì„±ì„ ì¡°íšŒí•˜ê³ ,
 * Extensionì„ globalThis.__SEPILOT_EXTENSIONS__ì— ìë™ ë“±ë¡í•©ë‹ˆë‹¤.
 *
 * Usage:
 *   node scripts/wrap-extension-renderer.js [extension-path]
 *   node scripts/wrap-extension-renderer.js resources/extensions/editor
 */

const fs = require('fs');
const path = require('path');

/**
 * CJS ë²ˆë“¤ ë˜í•‘
 *
 * @param {string} cjsPath - CJS ë²ˆë“¤ ê²½ë¡œ (dist/index.js)
 * @param {string} outputPath - ì¶œë ¥ ê²½ë¡œ (dist/renderer.js)
 */
function wrapRendererBundle(cjsPath, outputPath) {
  // íŒŒì¼ ì¡´ì¬ í™•ì¸
  if (!fs.existsSync(cjsPath)) {
    console.error(`âŒ CJS bundle not found: ${cjsPath}`);
    process.exit(1);
  }

  // CJS ë²ˆë“¤ ì½ê¸°
  let content;
  try {
    content = fs.readFileSync(cjsPath, 'utf-8');
  } catch (error) {
    console.error(`âŒ Failed to read CJS bundle: ${cjsPath}`, error);
    process.exit(1);
  }

  // ë‚´ìš© ê²€ì¦
  if (!content || content.trim().length === 0) {
    console.error(`âŒ Empty or invalid CJS bundle: ${cjsPath}`);
    process.exit(1);
  }

  // ë˜í¼ í—¤ë” (IIFE + Custom require)
  const wrapperHeader = `/**
 * Auto-generated by wrap-extension-renderer.js
 * DO NOT EDIT MANUALLY
 */
(function() {
  "use strict";

  // Module container
  var __m = { exports: {} };
  var __modules = (typeof globalThis !== 'undefined' ? globalThis : window).__SEPILOT_MODULES__ || {};

  /**
   * Custom require() implementation
   * Resolves modules from globalThis.__SEPILOT_MODULES__
   */
  function require(name) {
    // ì •í™•í•œ ì´ë¦„ ë§¤ì¹­
    if (__modules[name]) {
      return __modules[name];
    }

    // ì„œë¸ŒíŒ¨ìŠ¤ ë§¤ì¹­ (@radix-ui/*, @sepilot/extension-sdk/* ë“±)
    var parts = name.split('/');
    for (var i = parts.length; i > 0; i--) {
      var prefix = parts.slice(0, i).join('/');
      if (__modules[prefix]) {
        return __modules[prefix];
      }
    }

    // ëª¨ë“ˆì„ ì°¾ì§€ ëª»í•œ ê²½ìš°
    console.error('[Extension] Module not found in registry:', name);
    console.warn('[Extension] Available modules:', Object.keys(__modules).join(', '));
    return {};
  }

  // CommonJS í˜¸í™˜
  var module = __m;
  var exports = __m.exports;

  // --- Extension CJS Bundle Start ---
  try {
`;

  // ë˜í¼ í‘¸í„° (ìë™ ë“±ë¡)
  const wrapperFooter = `
  // --- Extension CJS Bundle End ---
  } catch (__bundleError) {
    console.error('[Extension] CJS bundle execution failed:', __bundleError);
  }

  // Extension ìë™ ë“±ë¡
  try {
    var _ext = __m.exports.default || __m.exports;
    var _id = _ext && _ext.manifest ? _ext.manifest.id : null;

    if (_id) {
      var _global = typeof globalThis !== 'undefined' ? globalThis : window;
      _global.__SEPILOT_EXTENSIONS__ = _global.__SEPILOT_EXTENSIONS__ || {};
      _global.__SEPILOT_EXTENSIONS__[_id] = __m.exports;
      console.log('[Extension] Registered:', _id);
    } else {
      console.warn('[Extension] Failed to extract extension ID from manifest');
      console.warn('[Extension] exports keys:', Object.keys(__m.exports));
    }
  } catch (error) {
    console.error('[Extension] Failed to register extension:', error);
  }
})();
`;

  // ë˜í•‘ëœ ë²ˆë“¤ ìƒì„±
  const wrappedContent = wrapperHeader + content + wrapperFooter;

  // ì¶œë ¥ ë””ë ‰í† ë¦¬ í™•ì¸
  const outputDir = path.dirname(outputPath);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // íŒŒì¼ ì“°ê¸°
  try {
    fs.writeFileSync(outputPath, wrappedContent, 'utf-8');
    console.log(`âœ… Wrapped renderer bundle: ${outputPath}`);
  } catch (error) {
    console.error(`âŒ Failed to write wrapped bundle: ${outputPath}`, error);
    process.exit(1);
  }
}

/**
 * Extension ë””ë ‰í† ë¦¬ì—ì„œ ë˜í•‘ ìˆ˜í–‰
 *
 * ì´ë¯¸ ë˜í•‘ëœ renderer.jsê°€ ìˆìœ¼ë©´ ê±´ë„ˆëœë‹ˆë‹¤ (ì´ì¤‘ ë˜í•‘ ë°©ì§€).
 * dist/renderer.jsê°€ ì¡´ì¬í•˜ì§€ë§Œ ë˜í•‘ë˜ì§€ ì•Šì€ ê²½ìš° (tsup renderer.tsx ë¹Œë“œ ê²°ê³¼),
 * dist/index.jsë¥¼ ë˜í•‘í•˜ì—¬ dist/renderer.jsë¡œ ì¶œë ¥í•©ë‹ˆë‹¤.
 *
 * @param {string} extensionPath - Extension ê²½ë¡œ (ì˜ˆ: resources/extensions/editor)
 */
function wrapExtension(extensionPath) {
  let cjsPath = path.join(extensionPath, 'dist', 'index.js');
  const outputPath = path.join(extensionPath, 'dist', 'renderer.js');

  // 1. ì´ë¯¸ ë˜í•‘ëœ renderer.jsê°€ ìˆìœ¼ë©´ ê±´ë„ˆë›°ê¸°
  if (fs.existsSync(outputPath)) {
    try {
      const existing = fs.readFileSync(outputPath, 'utf-8');
      if (existing.includes('__SEPILOT_MODULES__') && existing.includes('__SEPILOT_EXTENSIONS__')) {
        console.log(`  âŠ™ ${path.basename(extensionPath)}: renderer.js already wrapped, skipping`);
        return;
      }

      // 2. renderer.jsê°€ ì¡´ì¬í•˜ì§€ë§Œ ë˜í•‘ë˜ì§€ ì•ŠìŒ -> ì´ë¥¼ ì†ŒìŠ¤ë¡œ ì‚¬ìš© (In-place wrapping)
      // tsupì´ renderer.tsxë¥¼ renderer.jsë¡œ ë¹Œë“œí•œ ê²½ìš°
      console.log(`  â„¹ï¸  Detected unwrapped renderer.js, wrapping in-place...`);
      cjsPath = outputPath;
    } catch (e) {
      // ì½ê¸° ì‹¤íŒ¨, ë¬´ì‹œí•˜ê³  index.js ì‹œë„
    }
  }

  // 3. ì†ŒìŠ¤ íŒŒì¼(index.js í˜¹ì€ renderer.js) ì¡´ì¬ í™•ì¸
  if (!fs.existsSync(cjsPath)) {
    // jira-scrum ë“±ì˜ ê²½ìš° renderer.jsê°€ ì—†ê³  index.jsë§Œ ìˆì„ ìˆ˜ ìˆìŒ (ê¸°ì¡´ ë°©ì‹)
    // í•˜ì§€ë§Œ confluence/mail-file-watcherëŠ” ì´ì œ renderer.jsë§Œ ìˆìŒ.
    // cjsPathê°€ index.jsë¡œ ì„¤ì •ë˜ì–´ ìˆëŠ”ë° ì—†ì„ ìˆ˜ ìˆìŒ.
    if (cjsPath.endsWith('index.js')) {
      console.warn(`âŒ Source bundle not found: ${cjsPath} (and unwrapped renderer.js not found)`);
      return;
    }
  }

  console.log(`\nğŸ“¦ Wrapping extension: ${path.basename(extensionPath)}`);
  console.log(`   Source: ${path.relative(extensionPath, cjsPath)}`);
  console.log(`   Dest  : ${path.relative(extensionPath, outputPath)}`);

  wrapRendererBundle(cjsPath, outputPath);
}

/**
 * ëª¨ë“  Extension ë˜í•‘
 *
 * @param {string} extensionsDir - Extensions ë””ë ‰í† ë¦¬ (ì˜ˆ: resources/extensions)
 */
function wrapAllExtensions(extensionsDir) {
  if (!fs.existsSync(extensionsDir)) {
    console.error(`âŒ Extensions directory not found: ${extensionsDir}`);
    process.exit(1);
  }

  const entries = fs.readdirSync(extensionsDir, { withFileTypes: true });
  const extensionDirs = entries.filter((entry) => entry.isDirectory());

  if (extensionDirs.length === 0) {
    console.warn(`âš ï¸  No extensions found in: ${extensionsDir}`);
    return;
  }

  console.log(`\nğŸš€ Wrapping ${extensionDirs.length} extension(s)...\n`);

  let successCount = 0;
  let failureCount = 0;

  for (const dir of extensionDirs) {
    const extensionPath = path.join(extensionsDir, dir.name);
    const cjsPath = path.join(extensionPath, 'dist', 'index.js');

    if (!fs.existsSync(cjsPath)) {
      console.warn(`âš ï¸  Skipping ${dir.name} (no dist/index.js found)`);
      continue;
    }

    try {
      wrapExtension(extensionPath);
      successCount++;
    } catch (error) {
      console.error(`âŒ Failed to wrap ${dir.name}:`, error.message);
      failureCount++;
    }
  }

  console.log(`\nâœ… Wrapped ${successCount} extension(s)`);
  if (failureCount > 0) {
    console.error(`âŒ Failed to wrap ${failureCount} extension(s)`);
    process.exit(1);
  }
}

// CLI ì‹¤í–‰
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    // ì¸ì ì—†ìœ¼ë©´ ëª¨ë“  Extension ë˜í•‘
    const extensionsDir = path.join(__dirname, '..', 'resources', 'extensions');
    wrapAllExtensions(extensionsDir);
  } else {
    // íŠ¹ì • Extensionë§Œ ë˜í•‘
    const extensionPath = path.resolve(args[0]);
    wrapExtension(extensionPath);
  }
}

// Export for programmatic use
module.exports = {
  wrapRendererBundle,
  wrapExtension,
  wrapAllExtensions,
};
