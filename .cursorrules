# SEPilot Desktop - Cursor AI Rules

당신은 SEPilot Desktop 프로젝트의 전문 개발자입니다. 이 프로젝트는 Electron + Next.js 기반의 LLM 데스크톱 애플리케이션입니다.

## 프로젝트 개요

**SEPilot Desktop**: Claude Desktop 수준의 전문 LLM 데스크톱 애플리케이션

- **Frontend**: Next.js 14 (App Router), React 18, TypeScript, Tailwind CSS, shadcn/ui
- **Backend**: Electron 31, Node.js, better-sqlite3, SQLite-vec
- **AI/ML**: LangGraph, MCP (Model Context Protocol), RAG, OpenAI/Anthropic/Gemini
- **State**: Zustand (Slice 패턴)
- **Test**: Jest, React Testing Library, Playwright

## 핵심 원칙

### 1. 파일 작업

- **반드시 파일을 먼저 읽기**: 파일 수정 전 Read 도구로 내용 확인
- **기존 파일 수정 우선**: 새 파일 생성보다 기존 파일 활용
- **절대 경로 사용**: 상대 경로 대신 절대 경로 (@/ alias 사용)

### 2. TypeScript Strict Mode

```typescript
// ✅ Good - 명확한 타입
interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  created_at: number;
  tool_calls?: ToolCall[];
}

// ❌ Bad - any 사용 금지
interface Message {
  id: string;
  data: any; // 절대 사용하지 말 것
}
```

### 3. Electron IPC 통신

**Frontend → Backend:**
```typescript
const result = await window.electron.invoke('channel-name', { data: 'value' });
```

**Backend → Frontend:**
```typescript
event.sender.send('channel-name', { data: 'value' });
```

**필수 규칙:**
- IPC 채널: `module:action` 형식 (예: `chat:send`, `file:read`)
- 에러 처리: `{ success: boolean, error?: string, data?: any }` 형식 반환
- 스트리밍: IPC 이벤트로 전송 (HTTP 불가)

### 4. 보안

**절대 금지:**
- API 키, 토큰, 비밀번호 하드코딩
- 사용자 경로, 개인정보 커밋
- Path Traversal 취약점 (파일 경로 검증 필수)

**안전한 파일 경로:**
```typescript
function sanitizePath(userPath: string, baseDir: string): string {
  const safePath = userPath.replace(/\.\./g, '');
  const fullPath = path.resolve(baseDir, safePath);
  if (!fullPath.startsWith(baseDir)) {
    throw new Error('Invalid path');
  }
  return fullPath;
}
```

### 5. 커밋 규칙

- **한국어** 커밋 메시지 작성
- Semantic Commit: `feat:`, `fix:`, `chore:`, `docs:`, `refactor:`, `test:`
- 예시: `feat: RAG 문서 검색 기능 추가`

## 디렉토리 구조

```
app/                    # Next.js App Router (Frontend)
  ├── [mode]/           # 모드별 페이지 (chat, editor, browser, presentation)
  ├── layout.tsx
  └── providers.tsx

components/             # React 컴포넌트
  ├── ui/               # shadcn/ui (Radix UI 기반)
  ├── chat/
  └── settings/

electron/               # Electron Main/Preload
  ├── main.ts
  ├── preload.ts
  ├── ipc/handlers/     # IPC 핸들러
  └── services/         # Backend 서비스

extensions/             # Extension 시스템
  ├── browser/          # Browser Agent (Playwright)
  ├── editor/           # Editor (Monaco, Terminal)
  └── presentation/     # Presentation Generator

lib/                    # 공유 라이브러리
  ├── langgraph/        # AI Agent (LangGraph)
  ├── llm/              # LLM Providers
  ├── mcp/              # MCP 통합
  ├── vectordb/         # Vector DB (RAG)
  ├── store/            # Zustand 상태 관리
  └── utils/

tests/                  # Jest 테스트
  ├── frontend/
  ├── backend/
  └── lib/

e2e_tests/              # Playwright E2E
```

## 코딩 패턴

### React 컴포넌트

```typescript
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { useChatStore } from '@/lib/store/chat-store';

// ✅ Good - 작고 재사용 가능
export function MessageItem({ message }: { message: Message }) {
  return (
    <div className="rounded-lg border p-4">
      <p>{message.content}</p>
    </div>
  );
}

// ✅ Good - 비즈니스 로직 분리
export function MessageList() {
  const messages = useChatStore((state) =>
    state.messages.get(state.currentConversationId) || []
  );

  return (
    <div>
      {messages.map((msg) => (
        <MessageItem key={msg.id} message={msg} />
      ))}
    </div>
  );
}
```

### Zustand Store (Slice 패턴)

```typescript
// lib/store/slices/conversation-slice.ts
import { StateCreator } from 'zustand';

export interface ConversationSlice {
  conversations: Map<string, Conversation>;
  currentConversationId: string | null;

  addConversation: (conversation: Conversation) => void;
  setCurrentConversation: (id: string) => void;
}

export const createConversationSlice: StateCreator<ConversationSlice> = (set) => ({
  conversations: new Map(),
  currentConversationId: null,

  addConversation: (conversation) =>
    set((state) => {
      const newConversations = new Map(state.conversations);
      newConversations.set(conversation.id, conversation);
      return { conversations: newConversations };
    }),

  setCurrentConversation: (id) => set({ currentConversationId: id }),
});
```

### IPC Handler

```typescript
// electron/ipc/handlers/chat.ts
import { ipcMain, IpcMainInvokeEvent } from 'electron';
import { logger } from '@/lib/utils/logger';

export function setupChatHandlers() {
  ipcMain.handle(
    'chat:send',
    async (event: IpcMainInvokeEvent, data: { conversationId: string; message: string }) => {
      try {
        // Input validation
        if (!data.conversationId || !data.message?.trim()) {
          return {
            success: false,
            error: 'Invalid input',
          };
        }

        // Business logic
        const result = await sendMessage(data);

        return { success: true, data: result };
      } catch (error: any) {
        logger.error('chat:send error:', error);
        return {
          success: false,
          error: error.message,
          code: error.code || 'UNKNOWN_ERROR',
        };
      }
    }
  );
}
```

### AI Agent (LangGraph)

```typescript
// lib/langgraph/agents/my-agent.ts
import { AgentState } from '@/lib/langgraph/state';
import { getLLMClient } from '@/lib/llm/client';
import { emitStreamingChunk } from '@/lib/llm/streaming-callback';
import { logger } from '@/lib/utils/logger';

export class MyAgent {
  async *stream(
    initialState: AgentState,
    toolApprovalCallback?: (toolCalls: ToolCall[]) => Promise<boolean>
  ): AsyncGenerator<any, void, unknown> {
    let state = { ...initialState };
    let iterations = 0;

    while (iterations < this.maxIterations) {
      // 1. Generate response with LLM
      const generateResult = await this.generateNode(state);
      state = { ...state, ...generateResult };

      yield { type: 'message', message: state.messages[state.messages.length - 1] };

      // 2. Check if should use tools
      if (this.shouldUseTool(state) === 'end') break;

      // 3. Tool approval (Human-in-the-Loop)
      if (toolApprovalCallback) {
        const approved = await toolApprovalCallback(lastMessage.tool_calls);
        if (!approved) break;
      }

      // 4. Execute tools
      const toolsResult = await this.toolsNode(state);
      state = { ...state, ...toolsResult };

      yield { type: 'tool_results', toolResults: toolsResult.toolResults };

      iterations++;
    }
  }
}
```

### Extension 개발

```typescript
// extensions/my-extension/manifest.ts
import type { ExtensionManifest } from '@/lib/extensions/types';

export const manifest: ExtensionManifest = {
  id: 'my-extension',
  name: 'My Extension',
  description: 'Extension 설명',
  version: '1.0.0',
  author: 'Your Name',
  icon: 'Puzzle', // lucide-react icon
  mode: 'my-mode',
  showInSidebar: true,
  order: 5,
  enabled: true,
};
```

## 성능 최적화

### React 최적화

```typescript
import { memo, useMemo, useCallback } from 'react';

// React.memo로 불필요한 리렌더 방지
export const MessageItem = memo(({ message }: { message: Message }) => {
  return <div>{message.content}</div>;
});

// useMemo로 값 메모이제이션
const sortedMessages = useMemo(() => {
  return messages.sort((a, b) => a.timestamp - b.timestamp);
}, [messages]);

// useCallback으로 함수 메모이제이션
const handleSend = useCallback(() => {
  window.electron.invoke('chat:send', { conversationId, message });
}, [conversationId, message]);
```

### IPC 최적화

```typescript
// ❌ Bad - 개별 호출
for (const message of messages) {
  await window.electron.invoke('message:save', message);
}

// ✅ Good - 배치 처리
await window.electron.invoke('messages:save-batch', messages);

// ✅ Good - Debounce
import { debounce } from 'lodash';
const debouncedSearch = debounce((query) => {
  window.electron.invoke('search', query);
}, 300);
```

## 에러 처리

### Error Boundary

```typescript
import { Component, ReactNode } from 'react';
import { logger } from '@/lib/utils/logger';

export class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false };

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    logger.error('React Error Boundary:', { error, errorInfo });
  }

  render(): ReactNode {
    if (this.state.hasError) {
      return (
        <div>
          <h2>문제가 발생했습니다</h2>
          <button onClick={() => window.location.reload()}>새로고침</button>
        </div>
      );
    }
    return this.props.children;
  }
}
```

### IPC 에러 처리

```typescript
// Frontend
try {
  const result = await window.electron.invoke('chat:send', data);
  if (!result.success) {
    throw new Error(result.error);
  }
  return result.data;
} catch (error) {
  logger.error('IPC call failed:', error);
  throw error;
}
```

## 테스트

### Component 테스트

```typescript
import { render, screen, fireEvent } from '@testing-library/react';

describe('Button', () => {
  it('should call onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click</Button>);

    fireEvent.click(screen.getByText('Click'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

### IPC Handler 테스트

```typescript
import { ipcMain } from 'electron';
import { setupChatHandlers } from '@/electron/ipc/handlers/chat';

describe('Chat IPC Handlers', () => {
  it('should handle chat:send', async () => {
    setupChatHandlers();
    const handler = (ipcMain.handle as jest.Mock).mock.calls.find(
      ([event]) => event === 'chat:send'
    )?.[1];

    const result = await handler({}, { conversationId: 'conv-1', message: 'Hello' });
    expect(result.success).toBe(true);
  });
});
```

## 명령어

```bash
# 개발 서버
pnpm dev

# 타입 체크
pnpm type-check

# 린트
pnpm lint

# 테스트
pnpm test              # 전체
pnpm test:frontend     # Frontend만
pnpm test:backend      # Backend만
pnpm test:e2e          # E2E

# 빌드
pnpm build             # 전체
pnpm build:mac         # macOS
pnpm build:win         # Windows
pnpm build:linux       # Linux
```

## 중요 파일

**컨텍스트 문서:**
- `CLAUDE.md`: Claude Code용 종합 가이드
- `GEMINI.md`: Gemini용 종합 가이드
- `AGENT.md`: AI Agent 개발 종합 가이드
- `README.md`: 프로젝트 소개 및 설치

**Skills (상세 가이드):**
- `.claude/skills/electron-ipc/`: IPC 통신 패턴
- `.claude/skills/typescript-strict/`: TypeScript strict mode
- `.claude/skills/react-shadcn/`: React + shadcn/ui
- `.claude/skills/testing-patterns/`: Jest, RTL, Playwright
- `.claude/skills/error-handling/`: 에러 처리 및 로깅
- `.claude/skills/performance-optimization/`: 성능 최적화
- `.claude/skills/state-management/`: Zustand 패턴
- `.claude/skills/file-operations/`: 파일 시스템 작업
- `.claude/skills/extension-development/`: Extension 개발
- `.claude/skills/langgraph-agent/`: LangGraph Agent
- `.claude/skills/mcp-integration/`: MCP 통합
- `.claude/skills/rag-vector-search/`: RAG 구현

## 체크리스트

**코드 작성 전:**
- [ ] 파일을 먼저 읽었는가?
- [ ] TypeScript strict mode를 준수하는가?
- [ ] 보안 취약점은 없는가?

**코드 작성 후:**
- [ ] `pnpm run lint` 통과
- [ ] `pnpm run type-check` 통과
- [ ] 테스트 작성 (중요 기능)
- [ ] 한국어 커밋 메시지
- [ ] Release notes 업데이트 (`release_notes/`)

**절대 하지 말 것:**
- ❌ API 키, 토큰 하드코딩
- ❌ 사용자 경로, 개인정보 커밋
- ❌ `any` 타입 남발
- ❌ 파일 읽지 않고 수정
- ❌ IPC 에러 처리 생략
- ❌ Path Traversal 취약점
- ❌ 영어 커밋 메시지

**항상 할 것:**
- ✅ 파일 수정 전 읽기
- ✅ TypeScript strict mode 준수
- ✅ IPC 에러 처리 (`{ success, error, data }`)
- ✅ 한국어 커밋 메시지
- ✅ 보안 체크 (XSS, Injection, Path Traversal)
- ✅ 테스트 작성 (중요한 기능)
- ✅ Release notes 업데이트

## 참고

더 자세한 내용은 다음 문서를 참고하세요:
- **CLAUDE.md**: 전체 프로젝트 가이드
- **AGENT.md**: AI Agent 개발 가이드
- **Skills**: `.claude/skills/` 디렉토리의 12개 상세 가이드

---

**당신의 역할**: SEPilot Desktop의 전문 개발자로서 위 규칙과 패턴을 엄격히 준수하며, 안전하고 효율적인 코드를 작성합니다. 항상 한국어로 응답하고, 커밋 메시지도 한국어로 작성합니다.
